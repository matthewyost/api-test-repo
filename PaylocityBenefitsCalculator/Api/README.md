# Project Overview

## Problem Statement
Implement a backend solution where a user, an employee, has their paychecks 
calculated for a year based on the following requirements.

## Requirements

- Able to view employees and their dependents
- An employee may only have 1 spouse or domestic partner (not both)
- An employee may have an unlimited number of children
- Able to calculate and view a paycheck for an employee given the following rules:
  - 26 paychecks per year with deductions spread as evenly as possible on each paycheck
    employees have a base cost of $1,000 per month (for benefits)
  - Each dependent represents an additional $600 cost per month (for benefits)
  - Employees that make more than $80,000 per year will incur an additional 2% of their yearly salary in benefits costs
  - Dependents that are over 50 years old will incur an additional $200 per month

# Implementation

## Technologies
- .NET 6
- Entity Framework Core 6.0.32
- SQL Server
- Docker
- xUnit
- TestContainers.NET

## Architecture
- Api
  - Controllers
    - Contains the controllers for the API.
    - These are kept as thin as possible and only contain the necessary logic to handle the requests.
    - The controllers use the MediatR library to send commands and queries to the application layer.
    - Each controller has the `[ProducesResponseType]` attribute to specify the response types for each action and includes all potential status codes
      that I could see being used.
  - Cqs
    - The Command Query Separation pattern is used to separate the commands and queries.
    - Queries are used to retrieve data from the database.
    - Commands are used to perform actions on the database.
    - CQS pattern is achieved via the MediatR library.
    - Each command and query is a class that implements the `IRequest` interface.
    - The handlers for the commands and queries are implemented alongside the associated Request.
  - Data
    - Contains the data access layer including all contracts (interfaces) for the repositories.
    - Leveraging the repository pattern to abstract the data access layer.  This allows us to change out the underlying
      data access technology without affecting the rest of the application.
    - To configure the database, we use the Entity Framework's `IEntityTypeConfiguration` interface for each entity.
    - The `DataContext` class is used to configure the database context.
    - The `ServiceCollectionExtensions` class is used to simplify the registration of the data access layer with the DI container.
  - Dtos
    - Contains the data transfer objects used to transfer data between the API and the data access layer.
    - Due to security concerns, I altered the `EmployeeDto` and `DependentDto` to change the `Id` property to a `Guid` type.
      - This would prevent an attacker from guessing the `Id` of another employee or dependent and accessing their data.
  - Middleware
    - Contains the `ExceptionMiddleware` class which is used to handle exceptions globally.
    - This is meant to catch any unhandled exceptions and return a 500 status code with a message ensuring our API does not crash.
  - Migrations
    - Contains the database migrations generated by Entity Framework.
    - These are used to create the database schema.
    - To create a new migration, run the following command:
        ```
        dotnet ef migrations add <MigrationName> --project Api --startup-project Api
        ```
    - To apply the migrations to the database, run the following command:
        ```
        dotnet ef database update --project Api --startup-project Api
        ```
    - To remove the last migration, run the following command:
		```
		dotnet ef migrations remove --project Api --startup-project Api
		```
  - Models
  - Rules
    - Contains the rules for calculating the paycheck.
    - The `DeductionRuleEngine` class is used to calculate the deductions for an employee.
    - Each rule inherits from the `IDeductionRule` interface and is responsible for calculating a specific deduction.
    - The `ServiceCollectionExtensions` class is used to simplify the registration of the rules with the DI container.
      - Note:  These rules are loaded via reflection to simplify the registration of new rules.  If performance was a concern, we could manually register each rule
        or leverage an `IIncrementalGenerator` to generate the registration code at compile time.
- ApiTests
  - IntegrationTests
    - Contains the integration tests for the API.
    - Changed how these were performed to make them function in an automated test suite.
    - Each integration test accepts an `ApiWebApplicationFactory` which is used to create a new instance of the API using the `Microsoft.AspNetCore.Mvc.TestHost` library.
    - The `ApiWebApplicationFactory` class is responsible for creating the test server and configuring the services.
      - As part of this configuration, we replace the DbContext with one that uses a TestContainers.NET MsSQL container image.
      - This allows us to run the integration tests against a real database without affecting the development environment.
      - The `TestContainers.NET` library is used to manage the lifecycle of the container.
      - The `MsSqlContainer` class is used to configure the container image.
      - Using `IAsyncLifetime` to start and stop the container before and after the tests.
  - UnitTests
    -  Contains all of the unit tests for the API project.

## Running the Application
To run the application, you will need to have Docker installed on your machine.

1. Clone the repository.
2. Open a terminal and download the MsSQL container image by running the following command:
	```
	docker pull mcr.microsoft.com/mssql/server:2022-latest
	```
3. Run the following command to start the MsSQL container:
	```
	docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=yourStrong(!)Password" -p 1433:1433 --name mssql -d mcr.microsoft.com/mssql/server:2022-latest
	```
4. Open the solution in Visual Studio or your preferred IDE.
5. Set the `Api` project as the startup project.
6. Run the application.